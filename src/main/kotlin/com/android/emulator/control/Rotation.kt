// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.Rotation in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import kotlin.Any
import kotlin.Boolean
import kotlin.Double
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import okio.ByteString

class Rotation(
  /**
   * Can be inferred from z-axis as well.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.android.emulator.control.Rotation${'$'}SkinRotation#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val rotation: SkinRotation = SkinRotation.PORTRAIT,
  /**
   * Specifies the angle of rotation, in degrees [-180, 180]
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#DOUBLE",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val xAxis: Double = 0.0,
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#DOUBLE",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val yAxis: Double = 0.0,
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#DOUBLE",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val zAxis: Double = 0.0,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<Rotation, Rotation.Builder>(ADAPTER, unknownFields) {
  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.rotation = rotation
    builder.xAxis = xAxis
    builder.yAxis = yAxis
    builder.zAxis = zAxis
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is Rotation) return false
    if (unknownFields != other.unknownFields) return false
    if (rotation != other.rotation) return false
    if (xAxis != other.xAxis) return false
    if (yAxis != other.yAxis) return false
    if (zAxis != other.zAxis) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + rotation.hashCode()
      result = result * 37 + xAxis.hashCode()
      result = result * 37 + yAxis.hashCode()
      result = result * 37 + zAxis.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """rotation=$rotation"""
    result += """xAxis=$xAxis"""
    result += """yAxis=$yAxis"""
    result += """zAxis=$zAxis"""
    return result.joinToString(prefix = "Rotation{", separator = ", ", postfix = "}")
  }

  fun copy(
    rotation: SkinRotation = this.rotation,
    xAxis: Double = this.xAxis,
    yAxis: Double = this.yAxis,
    zAxis: Double = this.zAxis,
    unknownFields: ByteString = this.unknownFields
  ): Rotation = Rotation(rotation, xAxis, yAxis, zAxis, unknownFields)

  class Builder : Message.Builder<Rotation, Builder>() {
    @JvmField
    var rotation: SkinRotation = SkinRotation.PORTRAIT

    @JvmField
    var xAxis: Double = 0.0

    @JvmField
    var yAxis: Double = 0.0

    @JvmField
    var zAxis: Double = 0.0

    /**
     * Can be inferred from z-axis as well.
     */
    fun rotation(rotation: SkinRotation): Builder {
      this.rotation = rotation
      return this
    }

    /**
     * Specifies the angle of rotation, in degrees [-180, 180]
     */
    fun xAxis(xAxis: Double): Builder {
      this.xAxis = xAxis
      return this
    }

    fun yAxis(yAxis: Double): Builder {
      this.yAxis = yAxis
      return this
    }

    fun zAxis(zAxis: Double): Builder {
      this.zAxis = zAxis
      return this
    }

    override fun build(): Rotation = Rotation(
      rotation = rotation,
      xAxis = xAxis,
      yAxis = yAxis,
      zAxis = zAxis,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<Rotation> = object : ProtoAdapter<Rotation>(
      FieldEncoding.LENGTH_DELIMITED, 
      Rotation::class, 
      "type.googleapis.com/android.emulation.control.Rotation", 
      PROTO_3, 
      null
    ) {
      override fun encodedSize(value: Rotation): Int {
        var size = value.unknownFields.size
        if (value.rotation != SkinRotation.PORTRAIT) size +=
            SkinRotation.ADAPTER.encodedSizeWithTag(1, value.rotation)
        if (value.xAxis != 0.0) size += ProtoAdapter.DOUBLE.encodedSizeWithTag(2, value.xAxis)
        if (value.yAxis != 0.0) size += ProtoAdapter.DOUBLE.encodedSizeWithTag(3, value.yAxis)
        if (value.zAxis != 0.0) size += ProtoAdapter.DOUBLE.encodedSizeWithTag(4, value.zAxis)
        return size
      }

      override fun encode(writer: ProtoWriter, value: Rotation) {
        if (value.rotation != SkinRotation.PORTRAIT) SkinRotation.ADAPTER.encodeWithTag(writer, 1,
            value.rotation)
        if (value.xAxis != 0.0) ProtoAdapter.DOUBLE.encodeWithTag(writer, 2, value.xAxis)
        if (value.yAxis != 0.0) ProtoAdapter.DOUBLE.encodeWithTag(writer, 3, value.yAxis)
        if (value.zAxis != 0.0) ProtoAdapter.DOUBLE.encodeWithTag(writer, 4, value.zAxis)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): Rotation {
        var rotation: SkinRotation = SkinRotation.PORTRAIT
        var xAxis: Double = 0.0
        var yAxis: Double = 0.0
        var zAxis: Double = 0.0
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> try {
              rotation = SkinRotation.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            2 -> xAxis = ProtoAdapter.DOUBLE.decode(reader)
            3 -> yAxis = ProtoAdapter.DOUBLE.decode(reader)
            4 -> zAxis = ProtoAdapter.DOUBLE.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return Rotation(
          rotation = rotation,
          xAxis = xAxis,
          yAxis = yAxis,
          zAxis = zAxis,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: Rotation): Rotation = value.copy(
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }

  enum class SkinRotation(
    override val value: Int
  ) : WireEnum {
    /**
     * 0 degrees
     */
    PORTRAIT(0),

    /**
     * 90 degrees
     */
    LANDSCAPE(1),

    /**
     * -180 degrees
     */
    REVERSE_PORTRAIT(2),

    /**
     * -90 degrees
     */
    REVERSE_LANDSCAPE(3);

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<SkinRotation> = object : EnumAdapter<SkinRotation>(
        SkinRotation::class, 
        PROTO_3, 
        SkinRotation.PORTRAIT
      ) {
        override fun fromValue(value: Int): SkinRotation? = SkinRotation.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): SkinRotation? = when (value) {
        0 -> PORTRAIT
        1 -> LANDSCAPE
        2 -> REVERSE_PORTRAIT
        3 -> REVERSE_LANDSCAPE
        else -> null
      }
    }
  }
}
