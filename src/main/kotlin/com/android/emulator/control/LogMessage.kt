// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.LogMessage in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import com.squareup.wire.internal.checkElementsNotNull
import com.squareup.wire.internal.immutableCopyOf
import com.squareup.wire.internal.redactElements
import com.squareup.wire.internal.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.collections.List
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import okio.ByteString

class LogMessage(
  /**
   * [Output Only] The contents of the log output.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val contents: String = "",
  /**
   * The starting byte position of the output that was returned. This
   * should match the start parameter sent with the request. If the serial
   * console output exceeds the size of the buffer, older output will be
   * overwritten by newer content and the start values will be mismatched.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#INT64",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val start: Long = 0L,
  /**
   * [Output Only] The position of the next byte of content from the serial
   * console output. Use this value in the next request as the start
   * parameter.
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#INT64",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val next: Long = 0L,
  /**
   * Set the sort of response you are interested it in.
   * It the type is "Parsed" the entries field will contain the parsed
   * results. otherwise the contents field will be set.
   */
  @field:WireField(
    tag = 4,
    adapter = "com.android.emulator.control.LogMessage${'$'}LogType#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val sort: LogType = LogType.Text,
  entries: List<LogcatEntry> = emptyList(),
  unknownFields: ByteString = ByteString.EMPTY
) : Message<LogMessage, LogMessage.Builder>(ADAPTER, unknownFields) {
  /**
   * [Output Only] The parsed logcat entries so far. Only set if sort is
   * set to Parsed
   */
  @field:WireField(
    tag = 5,
    adapter = "com.android.emulator.control.LogcatEntry#ADAPTER",
    label = WireField.Label.REPEATED
  )
  @JvmField
  val entries: List<LogcatEntry> = immutableCopyOf("entries", entries)

  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.contents = contents
    builder.start = start
    builder.next = next
    builder.sort = sort
    builder.entries = entries
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is LogMessage) return false
    if (unknownFields != other.unknownFields) return false
    if (contents != other.contents) return false
    if (start != other.start) return false
    if (next != other.next) return false
    if (sort != other.sort) return false
    if (entries != other.entries) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + contents.hashCode()
      result = result * 37 + start.hashCode()
      result = result * 37 + next.hashCode()
      result = result * 37 + sort.hashCode()
      result = result * 37 + entries.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """contents=${sanitize(contents)}"""
    result += """start=$start"""
    result += """next=$next"""
    result += """sort=$sort"""
    if (entries.isNotEmpty()) result += """entries=$entries"""
    return result.joinToString(prefix = "LogMessage{", separator = ", ", postfix = "}")
  }

  fun copy(
    contents: String = this.contents,
    start: Long = this.start,
    next: Long = this.next,
    sort: LogType = this.sort,
    entries: List<LogcatEntry> = this.entries,
    unknownFields: ByteString = this.unknownFields
  ): LogMessage = LogMessage(contents, start, next, sort, entries, unknownFields)

  class Builder : Message.Builder<LogMessage, Builder>() {
    @JvmField
    var contents: String = ""

    @JvmField
    var start: Long = 0L

    @JvmField
    var next: Long = 0L

    @JvmField
    var sort: LogType = LogType.Text

    @JvmField
    var entries: List<LogcatEntry> = emptyList()

    /**
     * [Output Only] The contents of the log output.
     */
    fun contents(contents: String): Builder {
      this.contents = contents
      return this
    }

    /**
     * The starting byte position of the output that was returned. This
     * should match the start parameter sent with the request. If the serial
     * console output exceeds the size of the buffer, older output will be
     * overwritten by newer content and the start values will be mismatched.
     */
    fun start(start: Long): Builder {
      this.start = start
      return this
    }

    /**
     * [Output Only] The position of the next byte of content from the serial
     * console output. Use this value in the next request as the start
     * parameter.
     */
    fun next(next: Long): Builder {
      this.next = next
      return this
    }

    /**
     * Set the sort of response you are interested it in.
     * It the type is "Parsed" the entries field will contain the parsed
     * results. otherwise the contents field will be set.
     */
    fun sort(sort: LogType): Builder {
      this.sort = sort
      return this
    }

    /**
     * [Output Only] The parsed logcat entries so far. Only set if sort is
     * set to Parsed
     */
    fun entries(entries: List<LogcatEntry>): Builder {
      checkElementsNotNull(entries)
      this.entries = entries
      return this
    }

    override fun build(): LogMessage = LogMessage(
      contents = contents,
      start = start,
      next = next,
      sort = sort,
      entries = entries,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<LogMessage> = object : ProtoAdapter<LogMessage>(
      FieldEncoding.LENGTH_DELIMITED, 
      LogMessage::class, 
      "type.googleapis.com/android.emulation.control.LogMessage", 
      PROTO_3, 
      null
    ) {
      override fun encodedSize(value: LogMessage): Int {
        var size = value.unknownFields.size
        if (value.contents != "") size += ProtoAdapter.STRING.encodedSizeWithTag(1, value.contents)
        if (value.start != 0L) size += ProtoAdapter.INT64.encodedSizeWithTag(2, value.start)
        if (value.next != 0L) size += ProtoAdapter.INT64.encodedSizeWithTag(3, value.next)
        if (value.sort != LogType.Text) size += LogType.ADAPTER.encodedSizeWithTag(4, value.sort)
        size += LogcatEntry.ADAPTER.asRepeated().encodedSizeWithTag(5, value.entries)
        return size
      }

      override fun encode(writer: ProtoWriter, value: LogMessage) {
        if (value.contents != "") ProtoAdapter.STRING.encodeWithTag(writer, 1, value.contents)
        if (value.start != 0L) ProtoAdapter.INT64.encodeWithTag(writer, 2, value.start)
        if (value.next != 0L) ProtoAdapter.INT64.encodeWithTag(writer, 3, value.next)
        if (value.sort != LogType.Text) LogType.ADAPTER.encodeWithTag(writer, 4, value.sort)
        LogcatEntry.ADAPTER.asRepeated().encodeWithTag(writer, 5, value.entries)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): LogMessage {
        var contents: String = ""
        var start: Long = 0L
        var next: Long = 0L
        var sort: LogType = LogType.Text
        val entries = mutableListOf<LogcatEntry>()
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> contents = ProtoAdapter.STRING.decode(reader)
            2 -> start = ProtoAdapter.INT64.decode(reader)
            3 -> next = ProtoAdapter.INT64.decode(reader)
            4 -> try {
              sort = LogType.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            5 -> entries.add(LogcatEntry.ADAPTER.decode(reader))
            else -> reader.readUnknownField(tag)
          }
        }
        return LogMessage(
          contents = contents,
          start = start,
          next = next,
          sort = sort,
          entries = entries,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: LogMessage): LogMessage = value.copy(
        entries = value.entries.redactElements(LogcatEntry.ADAPTER),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }

  enum class LogType(
    override val value: Int
  ) : WireEnum {
    Text(0),

    Parsed(1);

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<LogType> = object : EnumAdapter<LogType>(
        LogType::class, 
        PROTO_3, 
        LogType.Text
      ) {
        override fun fromValue(value: Int): LogType? = LogType.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): LogType? = when (value) {
        0 -> Text
        1 -> Parsed
        else -> null
      }
    }
  }
}
