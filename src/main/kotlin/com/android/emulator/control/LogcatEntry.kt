// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.LogcatEntry in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import com.squareup.wire.internal.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import okio.ByteString

/**
 * A parsed logcat entry.
 */
class LogcatEntry(
  /**
   * A Unix timestamps in  milliseconds (The number of milliseconds that
   * have elapsed since January 1, 1970 (midnight UTC/GMT), not counting
   * leap seconds)
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#UINT64",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val timestamp: Long = 0L,
  /**
   * Process id.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#UINT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val pid: Int = 0,
  /**
   * Thread id.
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#UINT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val tid: Int = 0,
  @field:WireField(
    tag = 4,
    adapter = "com.android.emulator.control.LogcatEntry${'$'}LogLevel#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val level: LogLevel = LogLevel.UNKNOWN,
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val tag: String = "",
  @field:WireField(
    tag = 6,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val msg: String = "",
  unknownFields: ByteString = ByteString.EMPTY
) : Message<LogcatEntry, LogcatEntry.Builder>(ADAPTER, unknownFields) {
  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.timestamp = timestamp
    builder.pid = pid
    builder.tid = tid
    builder.level = level
    builder.tag = tag
    builder.msg = msg
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is LogcatEntry) return false
    if (unknownFields != other.unknownFields) return false
    if (timestamp != other.timestamp) return false
    if (pid != other.pid) return false
    if (tid != other.tid) return false
    if (level != other.level) return false
    if (tag != other.tag) return false
    if (msg != other.msg) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + timestamp.hashCode()
      result = result * 37 + pid.hashCode()
      result = result * 37 + tid.hashCode()
      result = result * 37 + level.hashCode()
      result = result * 37 + tag.hashCode()
      result = result * 37 + msg.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """timestamp=$timestamp"""
    result += """pid=$pid"""
    result += """tid=$tid"""
    result += """level=$level"""
    result += """tag=${sanitize(tag)}"""
    result += """msg=${sanitize(msg)}"""
    return result.joinToString(prefix = "LogcatEntry{", separator = ", ", postfix = "}")
  }

  fun copy(
    timestamp: Long = this.timestamp,
    pid: Int = this.pid,
    tid: Int = this.tid,
    level: LogLevel = this.level,
    tag: String = this.tag,
    msg: String = this.msg,
    unknownFields: ByteString = this.unknownFields
  ): LogcatEntry = LogcatEntry(timestamp, pid, tid, level, tag, msg, unknownFields)

  class Builder : Message.Builder<LogcatEntry, Builder>() {
    @JvmField
    var timestamp: Long = 0L

    @JvmField
    var pid: Int = 0

    @JvmField
    var tid: Int = 0

    @JvmField
    var level: LogLevel = LogLevel.UNKNOWN

    @JvmField
    var tag: String = ""

    @JvmField
    var msg: String = ""

    /**
     * A Unix timestamps in  milliseconds (The number of milliseconds that
     * have elapsed since January 1, 1970 (midnight UTC/GMT), not counting
     * leap seconds)
     */
    fun timestamp(timestamp: Long): Builder {
      this.timestamp = timestamp
      return this
    }

    /**
     * Process id.
     */
    fun pid(pid: Int): Builder {
      this.pid = pid
      return this
    }

    /**
     * Thread id.
     */
    fun tid(tid: Int): Builder {
      this.tid = tid
      return this
    }

    fun level(level: LogLevel): Builder {
      this.level = level
      return this
    }

    fun tag(tag: String): Builder {
      this.tag = tag
      return this
    }

    fun msg(msg: String): Builder {
      this.msg = msg
      return this
    }

    override fun build(): LogcatEntry = LogcatEntry(
      timestamp = timestamp,
      pid = pid,
      tid = tid,
      level = level,
      tag = tag,
      msg = msg,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<LogcatEntry> = object : ProtoAdapter<LogcatEntry>(
      FieldEncoding.LENGTH_DELIMITED, 
      LogcatEntry::class, 
      "type.googleapis.com/android.emulation.control.LogcatEntry", 
      PROTO_3, 
      null
    ) {
      override fun encodedSize(value: LogcatEntry): Int {
        var size = value.unknownFields.size
        if (value.timestamp != 0L) size += ProtoAdapter.UINT64.encodedSizeWithTag(1,
            value.timestamp)
        if (value.pid != 0) size += ProtoAdapter.UINT32.encodedSizeWithTag(2, value.pid)
        if (value.tid != 0) size += ProtoAdapter.UINT32.encodedSizeWithTag(3, value.tid)
        if (value.level != LogLevel.UNKNOWN) size += LogLevel.ADAPTER.encodedSizeWithTag(4,
            value.level)
        if (value.tag != "") size += ProtoAdapter.STRING.encodedSizeWithTag(5, value.tag)
        if (value.msg != "") size += ProtoAdapter.STRING.encodedSizeWithTag(6, value.msg)
        return size
      }

      override fun encode(writer: ProtoWriter, value: LogcatEntry) {
        if (value.timestamp != 0L) ProtoAdapter.UINT64.encodeWithTag(writer, 1, value.timestamp)
        if (value.pid != 0) ProtoAdapter.UINT32.encodeWithTag(writer, 2, value.pid)
        if (value.tid != 0) ProtoAdapter.UINT32.encodeWithTag(writer, 3, value.tid)
        if (value.level != LogLevel.UNKNOWN) LogLevel.ADAPTER.encodeWithTag(writer, 4, value.level)
        if (value.tag != "") ProtoAdapter.STRING.encodeWithTag(writer, 5, value.tag)
        if (value.msg != "") ProtoAdapter.STRING.encodeWithTag(writer, 6, value.msg)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): LogcatEntry {
        var timestamp: Long = 0L
        var pid: Int = 0
        var tid: Int = 0
        var level: LogLevel = LogLevel.UNKNOWN
        var tag: String = ""
        var msg: String = ""
        val unknownFields = reader.forEachTag { tag_ ->
          when (tag_) {
            1 -> timestamp = ProtoAdapter.UINT64.decode(reader)
            2 -> pid = ProtoAdapter.UINT32.decode(reader)
            3 -> tid = ProtoAdapter.UINT32.decode(reader)
            4 -> try {
              level = LogLevel.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag_, FieldEncoding.VARINT, e.value.toLong())
            }
            5 -> tag = ProtoAdapter.STRING.decode(reader)
            6 -> msg = ProtoAdapter.STRING.decode(reader)
            else -> reader.readUnknownField(tag_)
          }
        }
        return LogcatEntry(
          timestamp = timestamp,
          pid = pid,
          tid = tid,
          level = level,
          tag = tag,
          msg = msg,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: LogcatEntry): LogcatEntry = value.copy(
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }

  /**
   * The possible log levels.
   */
  enum class LogLevel(
    override val value: Int
  ) : WireEnum {
    UNKNOWN(0),

    DEFAULT(1),

    VERBOSE(2),

    DEBUG(3),

    INFO(4),

    WARN(5),

    ERR(6),

    FATAL(7),

    SILENT(8);

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<LogLevel> = object : EnumAdapter<LogLevel>(
        LogLevel::class, 
        PROTO_3, 
        LogLevel.UNKNOWN
      ) {
        override fun fromValue(value: Int): LogLevel? = LogLevel.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): LogLevel? = when (value) {
        0 -> UNKNOWN
        1 -> DEFAULT
        2 -> VERBOSE
        3 -> DEBUG
        4 -> INFO
        5 -> WARN
        6 -> ERR
        7 -> FATAL
        8 -> SILENT
        else -> null
      }
    }
  }
}
