// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.Rtc in rtc_service.proto
package com.android.emulator.control

import com.squareup.wire.GrpcCall
import com.squareup.wire.GrpcClient
import com.squareup.wire.GrpcMethod
import com.squareup.wire.GrpcStreamingCall
import com.squareup.wire.ProtoAdapter
import kotlin.Unit

/**
 * An RTC service lets you interact with the emulator through WebRTC
 * Note that this is currently an experimental feature, and that the
 * service definition might change without notice. Use at your own risk!
 *
 * The following endpoints are needed to establish the webrtc protocol
 * Due to limitiations in Javascript we cannot make use of bidirectional
 * endpoints See this [blog](https://grpc.io/blog/state-of-grpc-web) for
 * details.
 */
class GrpcRtcClient(
  private val client: GrpcClient
) : RtcClient {
  /**
   * This function will generate a new identifier that the client
   * should use for further interaction. It will initiate the
   * JSEP protocol on the server side.
   */
  override fun requestRtcStream(): GrpcCall<Unit, RtcId> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.Rtc/requestRtcStream",
      requestAdapter = ProtoAdapter.EMPTY,
      responseAdapter = RtcId.ADAPTER
  ))

  /**
   * Sends the given JsepMsg to the server. The RtcId in the
   * message should point to an active stream negotiation in
   * progress, otherwise the message will be ignored.
   */
  override fun sendJsepMessage(): GrpcCall<JsepMsg, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.Rtc/sendJsepMessage",
      requestAdapter = JsepMsg.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  /**
   * Reads an available jsep messages for the given client id,
   * blocking until one becomes available. Do not use the polling version
   * above if you opt for this one.
   *
   * The ice candidates for example will trickle in on this callback,
   * as will the SDP negotation.
   */
  override fun receiveJsepMessages(): GrpcStreamingCall<RtcId, JsepMsg> =
      client.newStreamingCall(GrpcMethod(
      path = "/android.emulation.control.Rtc/receiveJsepMessages",
      requestAdapter = RtcId.ADAPTER,
      responseAdapter = JsepMsg.ADAPTER
  ))

  /**
   * [DEPRECATED] This is only here as the go grpc webproxy used
   * by fuchsia does not support server side streaming. This method
   * will be removed in the future and should not be relied upon.
   *
   * Reads an available jsep messages for the given client id,
   * blocking until one becomes available. Do not use the polling version
   * above if you opt for this one.
   *
   * The ice candidates for example will trickle in on this callback,
   * as will the SDP negotation.
   */
  override fun receiveJsepMessage(): GrpcCall<RtcId, JsepMsg> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.Rtc/receiveJsepMessage",
      requestAdapter = RtcId.ADAPTER,
      responseAdapter = JsepMsg.ADAPTER
  ))
}
