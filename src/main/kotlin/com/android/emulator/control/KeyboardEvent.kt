// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.KeyboardEvent in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import com.squareup.wire.internal.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import okio.ByteString

/**
 * KeyboardEvent objects describe a user interaction with the keyboard; each
 * event describes a single interaction between the user and a key (or
 * combination of a key with modifier keys) on the keyboard.
 * This follows the pattern as set by
 * (javascript)[https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent]
 *
 * Note: that only keyCode, key, or text can be set and that the semantics
 * will slightly vary.
 */
class KeyboardEvent(
  /**
   * Type of keycode contained in the keyCode field.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.android.emulator.control.KeyboardEvent${'$'}KeyCodeType#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val codeType: KeyCodeType = KeyCodeType.Usb,
  /**
   * The type of keyboard event that should be sent to the emulator
   */
  @field:WireField(
    tag = 2,
    adapter = "com.android.emulator.control.KeyboardEvent${'$'}KeyEventType#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val eventType: KeyEventType = KeyEventType.keydown,
  /**
   * This property represents a physical key on the keyboard (as opposed
   * to the character generated by pressing the key). In other words, this
   * property is a value which isn't altered by keyboard layout or the
   * state of the modifier keys. This value will be interpreted by the
   * emulator depending on the KeyCodeType. The incoming key code will be
   * translated to an evdev code type and send to the emulator.
   * The values in key and text will be ignored.
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val keyCode: Int = 0,
  /**
   * The value of the key pressed by the user, taking into consideration
   * the state of modifier keys such as Shift as well as the keyboard
   * locale and layout. This follows the w3c standard used in browsers.
   * You can find an accurate description of valid values
   * [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
   *
   * Note that some keys can result in multiple evdev events that are
   * delivered to the emulator. for example the Key "A" will result in a
   * sequence:
   * ["Shift", "a"] -> [0x2a, 0x1e] whereas "a" results in ["a"] -> [0x1e].
   *
   * Not all documented keys are understood by android, and only printable
   * ASCII [32-127) characters are properly translated.
   *
   * Keep in mind that there are a set of key values that result in android
   * specific behavior
   * [see](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values#Phone_keys):
   *
   * - "AppSwitch": Behaves as the "Overview" button in android.
   * - "GoBack": The Back button.
   * - "GoHome": The Home button, which takes the user to the phone's main
   *             screen (usually an application launcher).
   * - "Power":  The Power button.
   */
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val key: String = "",
  /**
   * Series of utf8 encoded characters to send to the emulator. An attempt
   * will be made to translate every character will an EvDev event type and
   * send to the emulator as a keypress event. The values in keyCode,
   * eventType, codeType and key will be ignored.
   *
   * Note that most printable ASCII characters (range [32-127) can be send
   * individually with the "key" param. Do not expect arbitrary UTF symbols to
   * arrive in the emulator (most will be ignored).
   */
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val text: String = "",
  unknownFields: ByteString = ByteString.EMPTY
) : Message<KeyboardEvent, KeyboardEvent.Builder>(ADAPTER, unknownFields) {
  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.codeType = codeType
    builder.eventType = eventType
    builder.keyCode = keyCode
    builder.key = key
    builder.text = text
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is KeyboardEvent) return false
    if (unknownFields != other.unknownFields) return false
    if (codeType != other.codeType) return false
    if (eventType != other.eventType) return false
    if (keyCode != other.keyCode) return false
    if (key != other.key) return false
    if (text != other.text) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + codeType.hashCode()
      result = result * 37 + eventType.hashCode()
      result = result * 37 + keyCode.hashCode()
      result = result * 37 + key.hashCode()
      result = result * 37 + text.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """codeType=$codeType"""
    result += """eventType=$eventType"""
    result += """keyCode=$keyCode"""
    result += """key=${sanitize(key)}"""
    result += """text=${sanitize(text)}"""
    return result.joinToString(prefix = "KeyboardEvent{", separator = ", ", postfix = "}")
  }

  fun copy(
    codeType: KeyCodeType = this.codeType,
    eventType: KeyEventType = this.eventType,
    keyCode: Int = this.keyCode,
    key: String = this.key,
    text: String = this.text,
    unknownFields: ByteString = this.unknownFields
  ): KeyboardEvent = KeyboardEvent(codeType, eventType, keyCode, key, text, unknownFields)

  class Builder : Message.Builder<KeyboardEvent, Builder>() {
    @JvmField
    var codeType: KeyCodeType = KeyCodeType.Usb

    @JvmField
    var eventType: KeyEventType = KeyEventType.keydown

    @JvmField
    var keyCode: Int = 0

    @JvmField
    var key: String = ""

    @JvmField
    var text: String = ""

    /**
     * Type of keycode contained in the keyCode field.
     */
    fun codeType(codeType: KeyCodeType): Builder {
      this.codeType = codeType
      return this
    }

    /**
     * The type of keyboard event that should be sent to the emulator
     */
    fun eventType(eventType: KeyEventType): Builder {
      this.eventType = eventType
      return this
    }

    /**
     * This property represents a physical key on the keyboard (as opposed
     * to the character generated by pressing the key). In other words, this
     * property is a value which isn't altered by keyboard layout or the
     * state of the modifier keys. This value will be interpreted by the
     * emulator depending on the KeyCodeType. The incoming key code will be
     * translated to an evdev code type and send to the emulator.
     * The values in key and text will be ignored.
     */
    fun keyCode(keyCode: Int): Builder {
      this.keyCode = keyCode
      return this
    }

    /**
     * The value of the key pressed by the user, taking into consideration
     * the state of modifier keys such as Shift as well as the keyboard
     * locale and layout. This follows the w3c standard used in browsers.
     * You can find an accurate description of valid values
     * [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
     *
     * Note that some keys can result in multiple evdev events that are
     * delivered to the emulator. for example the Key "A" will result in a
     * sequence:
     * ["Shift", "a"] -> [0x2a, 0x1e] whereas "a" results in ["a"] -> [0x1e].
     *
     * Not all documented keys are understood by android, and only printable
     * ASCII [32-127) characters are properly translated.
     *
     * Keep in mind that there are a set of key values that result in android
     * specific behavior
     * [see](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values#Phone_keys):
     *
     * - "AppSwitch": Behaves as the "Overview" button in android.
     * - "GoBack": The Back button.
     * - "GoHome": The Home button, which takes the user to the phone's main
     *             screen (usually an application launcher).
     * - "Power":  The Power button.
     */
    fun key(key: String): Builder {
      this.key = key
      return this
    }

    /**
     * Series of utf8 encoded characters to send to the emulator. An attempt
     * will be made to translate every character will an EvDev event type and
     * send to the emulator as a keypress event. The values in keyCode,
     * eventType, codeType and key will be ignored.
     *
     * Note that most printable ASCII characters (range [32-127) can be send
     * individually with the "key" param. Do not expect arbitrary UTF symbols to
     * arrive in the emulator (most will be ignored).
     */
    fun text(text: String): Builder {
      this.text = text
      return this
    }

    override fun build(): KeyboardEvent = KeyboardEvent(
      codeType = codeType,
      eventType = eventType,
      keyCode = keyCode,
      key = key,
      text = text,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<KeyboardEvent> = object : ProtoAdapter<KeyboardEvent>(
      FieldEncoding.LENGTH_DELIMITED, 
      KeyboardEvent::class, 
      "type.googleapis.com/android.emulation.control.KeyboardEvent", 
      PROTO_3, 
      null
    ) {
      override fun encodedSize(value: KeyboardEvent): Int {
        var size = value.unknownFields.size
        if (value.codeType != KeyCodeType.Usb) size += KeyCodeType.ADAPTER.encodedSizeWithTag(1,
            value.codeType)
        if (value.eventType != KeyEventType.keydown) size +=
            KeyEventType.ADAPTER.encodedSizeWithTag(2, value.eventType)
        if (value.keyCode != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(3, value.keyCode)
        if (value.key != "") size += ProtoAdapter.STRING.encodedSizeWithTag(4, value.key)
        if (value.text != "") size += ProtoAdapter.STRING.encodedSizeWithTag(5, value.text)
        return size
      }

      override fun encode(writer: ProtoWriter, value: KeyboardEvent) {
        if (value.codeType != KeyCodeType.Usb) KeyCodeType.ADAPTER.encodeWithTag(writer, 1,
            value.codeType)
        if (value.eventType != KeyEventType.keydown) KeyEventType.ADAPTER.encodeWithTag(writer, 2,
            value.eventType)
        if (value.keyCode != 0) ProtoAdapter.INT32.encodeWithTag(writer, 3, value.keyCode)
        if (value.key != "") ProtoAdapter.STRING.encodeWithTag(writer, 4, value.key)
        if (value.text != "") ProtoAdapter.STRING.encodeWithTag(writer, 5, value.text)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): KeyboardEvent {
        var codeType: KeyCodeType = KeyCodeType.Usb
        var eventType: KeyEventType = KeyEventType.keydown
        var keyCode: Int = 0
        var key: String = ""
        var text: String = ""
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> try {
              codeType = KeyCodeType.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            2 -> try {
              eventType = KeyEventType.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            3 -> keyCode = ProtoAdapter.INT32.decode(reader)
            4 -> key = ProtoAdapter.STRING.decode(reader)
            5 -> text = ProtoAdapter.STRING.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return KeyboardEvent(
          codeType = codeType,
          eventType = eventType,
          keyCode = keyCode,
          key = key,
          text = text,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: KeyboardEvent): KeyboardEvent = value.copy(
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }

  /**
   * Code types that the emulator can receive. Note that the emulator
   * will do its best to translate the code to an evdev value that
   * will be send to the emulator. This translation is based on
   * the chromium translation tables. See
   * (this)[https://android.googlesource.com/platform/external/qemu/+/refs/heads/emu-master-dev/android/android-grpc/android/emulation/control/keyboard/keycode_converter_data.inc]
   * for details on the translation.
   */
  enum class KeyCodeType(
    override val value: Int
  ) : WireEnum {
    Usb(0),

    Evdev(1),

    XKB(2),

    Win(3),

    Mac(4);

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<KeyCodeType> = object : EnumAdapter<KeyCodeType>(
        KeyCodeType::class, 
        PROTO_3, 
        KeyCodeType.Usb
      ) {
        override fun fromValue(value: Int): KeyCodeType? = KeyCodeType.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): KeyCodeType? = when (value) {
        0 -> Usb
        1 -> Evdev
        2 -> XKB
        3 -> Win
        4 -> Mac
        else -> null
      }
    }
  }

  enum class KeyEventType(
    override val value: Int
  ) : WireEnum {
    /**
     * Indicates that this keyevent should be send to the emulator
     * as a key down event. Meaning that the key event will be
     * translated to an EvDev event type and bit 11 (0x400) will be
     * set before it is sent to the emulator.
     */
    keydown(0),

    /**
     * Indicates that the keyevent should be send to the emulator
     * as a key up event. Meaning that the key event will be
     * translated to an EvDev event type and
     * sent to the emulator.
     */
    keyup(1),

    /**
     * Indicates that the keyevent will be send to the emulator
     * as e key down event and immediately followed by a keyup event.
     */
    keypress(2);

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<KeyEventType> = object : EnumAdapter<KeyEventType>(
        KeyEventType::class, 
        PROTO_3, 
        KeyEventType.keydown
      ) {
        override fun fromValue(value: Int): KeyEventType? = KeyEventType.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): KeyEventType? = when (value) {
        0 -> keydown
        1 -> keyup
        2 -> keypress
        else -> null
      }
    }
  }
}
