// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.Touch in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.hashCode
import kotlin.jvm.JvmField
import okio.ByteString

/**
 * The Touch interface represents a single contact point on a
 * touch-sensitive device. The contact point is commonly a finger or stylus
 * and the device may be a touchscreen or trackpad.
 */
class Touch(
  /**
   * The horizontal coordinate. This is the physical location on the
   * screen For example 0 indicates the leftmost coordinate.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val x: Int = 0,
  /**
   * The vertical coordinate. This is the physical location on the screen
   * For example 0 indicates the top left coordinate.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val y: Int = 0,
  /**
   * The identifier is an arbitrary non-negative integer that is used to
   * identify and track each tool independently when multiple tools are
   * active. For example, when multiple fingers are touching the device,
   * each finger should be assigned a distinct tracking id that is used as
   * long as the finger remains in contact. Tracking ids may be reused
   * when their associated tools move out of range.
   *
   * The emulator currently supports up to 10 concurrent touch events. The
   * identifier should be a value from the set [0, 10]
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val identifier: Int = 0,
  /**
   * Reports the physical pressure applied to the tip of the tool or the
   * signal strength of the touch contact.
   *
   * The values reported must be non-zero when the tool is touching the
   * device and zero otherwise to indicate that the touch event is
   * completed.
   *
   * Make sure to deliver a pressure of 0 for the given identifier when
   * the touch event is completed, otherwise the touch identifier will not
   * be unregistered!
   */
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val pressure: Int = 0,
  /**
   * Optionally reports the cross-sectional area of the touch contact, or
   * the length of the longer dimension of the touch contact.
   */
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "touchMajor"
  )
  @JvmField
  val touch_major: Int = 0,
  /**
   * Optionally reports the length of the shorter dimension of the touch
   * contact. This axis will be ignored if touch_major is reporting an
   * area measurement greater than 0.
   */
  @field:WireField(
    tag = 6,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "touchMinor"
  )
  @JvmField
  val touch_minor: Int = 0,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<Touch, Touch.Builder>(ADAPTER, unknownFields) {
  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.x = x
    builder.y = y
    builder.identifier = identifier
    builder.pressure = pressure
    builder.touch_major = touch_major
    builder.touch_minor = touch_minor
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is Touch) return false
    if (unknownFields != other.unknownFields) return false
    if (x != other.x) return false
    if (y != other.y) return false
    if (identifier != other.identifier) return false
    if (pressure != other.pressure) return false
    if (touch_major != other.touch_major) return false
    if (touch_minor != other.touch_minor) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + x.hashCode()
      result = result * 37 + y.hashCode()
      result = result * 37 + identifier.hashCode()
      result = result * 37 + pressure.hashCode()
      result = result * 37 + touch_major.hashCode()
      result = result * 37 + touch_minor.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """x=$x"""
    result += """y=$y"""
    result += """identifier=$identifier"""
    result += """pressure=$pressure"""
    result += """touch_major=$touch_major"""
    result += """touch_minor=$touch_minor"""
    return result.joinToString(prefix = "Touch{", separator = ", ", postfix = "}")
  }

  fun copy(
    x: Int = this.x,
    y: Int = this.y,
    identifier: Int = this.identifier,
    pressure: Int = this.pressure,
    touch_major: Int = this.touch_major,
    touch_minor: Int = this.touch_minor,
    unknownFields: ByteString = this.unknownFields
  ): Touch = Touch(x, y, identifier, pressure, touch_major, touch_minor, unknownFields)

  class Builder : Message.Builder<Touch, Builder>() {
    @JvmField
    var x: Int = 0

    @JvmField
    var y: Int = 0

    @JvmField
    var identifier: Int = 0

    @JvmField
    var pressure: Int = 0

    @JvmField
    var touch_major: Int = 0

    @JvmField
    var touch_minor: Int = 0

    /**
     * The horizontal coordinate. This is the physical location on the
     * screen For example 0 indicates the leftmost coordinate.
     */
    fun x(x: Int): Builder {
      this.x = x
      return this
    }

    /**
     * The vertical coordinate. This is the physical location on the screen
     * For example 0 indicates the top left coordinate.
     */
    fun y(y: Int): Builder {
      this.y = y
      return this
    }

    /**
     * The identifier is an arbitrary non-negative integer that is used to
     * identify and track each tool independently when multiple tools are
     * active. For example, when multiple fingers are touching the device,
     * each finger should be assigned a distinct tracking id that is used as
     * long as the finger remains in contact. Tracking ids may be reused
     * when their associated tools move out of range.
     *
     * The emulator currently supports up to 10 concurrent touch events. The
     * identifier should be a value from the set [0, 10]
     */
    fun identifier(identifier: Int): Builder {
      this.identifier = identifier
      return this
    }

    /**
     * Reports the physical pressure applied to the tip of the tool or the
     * signal strength of the touch contact.
     *
     * The values reported must be non-zero when the tool is touching the
     * device and zero otherwise to indicate that the touch event is
     * completed.
     *
     * Make sure to deliver a pressure of 0 for the given identifier when
     * the touch event is completed, otherwise the touch identifier will not
     * be unregistered!
     */
    fun pressure(pressure: Int): Builder {
      this.pressure = pressure
      return this
    }

    /**
     * Optionally reports the cross-sectional area of the touch contact, or
     * the length of the longer dimension of the touch contact.
     */
    fun touch_major(touch_major: Int): Builder {
      this.touch_major = touch_major
      return this
    }

    /**
     * Optionally reports the length of the shorter dimension of the touch
     * contact. This axis will be ignored if touch_major is reporting an
     * area measurement greater than 0.
     */
    fun touch_minor(touch_minor: Int): Builder {
      this.touch_minor = touch_minor
      return this
    }

    override fun build(): Touch = Touch(
      x = x,
      y = y,
      identifier = identifier,
      pressure = pressure,
      touch_major = touch_major,
      touch_minor = touch_minor,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<Touch> = object : ProtoAdapter<Touch>(
      FieldEncoding.LENGTH_DELIMITED, 
      Touch::class, 
      "type.googleapis.com/android.emulation.control.Touch", 
      PROTO_3, 
      null
    ) {
      override fun encodedSize(value: Touch): Int {
        var size = value.unknownFields.size
        if (value.x != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(1, value.x)
        if (value.y != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(2, value.y)
        if (value.identifier != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(3,
            value.identifier)
        if (value.pressure != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(4, value.pressure)
        if (value.touch_major != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(5,
            value.touch_major)
        if (value.touch_minor != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(6,
            value.touch_minor)
        return size
      }

      override fun encode(writer: ProtoWriter, value: Touch) {
        if (value.x != 0) ProtoAdapter.INT32.encodeWithTag(writer, 1, value.x)
        if (value.y != 0) ProtoAdapter.INT32.encodeWithTag(writer, 2, value.y)
        if (value.identifier != 0) ProtoAdapter.INT32.encodeWithTag(writer, 3, value.identifier)
        if (value.pressure != 0) ProtoAdapter.INT32.encodeWithTag(writer, 4, value.pressure)
        if (value.touch_major != 0) ProtoAdapter.INT32.encodeWithTag(writer, 5, value.touch_major)
        if (value.touch_minor != 0) ProtoAdapter.INT32.encodeWithTag(writer, 6, value.touch_minor)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): Touch {
        var x: Int = 0
        var y: Int = 0
        var identifier: Int = 0
        var pressure: Int = 0
        var touch_major: Int = 0
        var touch_minor: Int = 0
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> x = ProtoAdapter.INT32.decode(reader)
            2 -> y = ProtoAdapter.INT32.decode(reader)
            3 -> identifier = ProtoAdapter.INT32.decode(reader)
            4 -> pressure = ProtoAdapter.INT32.decode(reader)
            5 -> touch_major = ProtoAdapter.INT32.decode(reader)
            6 -> touch_minor = ProtoAdapter.INT32.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return Touch(
          x = x,
          y = y,
          identifier = identifier,
          pressure = pressure,
          touch_major = touch_major,
          touch_minor = touch_minor,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: Touch): Touch = value.copy(
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
