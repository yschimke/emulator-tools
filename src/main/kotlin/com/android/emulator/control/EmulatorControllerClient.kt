// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.EmulatorController in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.GrpcCall
import com.squareup.wire.GrpcStreamingCall
import com.squareup.wire.Service
import kotlin.Unit

/**
 * An EmulatorController service lets you control the emulator.
 * Note that this is currently an experimental feature, and that the
 * service definition might change without notice. Use at your own risk!
 *
 * We use the following rough conventions:
 *
 * streamXXX --> streams values XXX (usually for emulator lifetime). Values
 *               are updated as soon as they become available.
 * getXXX    --> gets a single value XXX
 * setXXX    --> sets a single value XXX, does not returning state, these
 *               usually have an observable lasting side effect.
 * sendXXX   --> send a single event XXX, possibly returning state information.
 *               android usually responds to these events.
 */
interface EmulatorControllerClient : Service {
  /**
   * set/get/stream the sensor data
   */
  fun streamSensor(): GrpcStreamingCall<SensorValue, SensorValue>

  fun getSensor(): GrpcCall<SensorValue, SensorValue>

  fun setSensor(): GrpcCall<SensorValue, Unit>

  /**
   * set/get/stream the physical model, this is likely the one you are
   * looking for when you wish to modify the device state.
   */
  fun setPhysicalModel(): GrpcCall<PhysicalModelValue, Unit>

  fun getPhysicalModel(): GrpcCall<PhysicalModelValue, PhysicalModelValue>

  fun streamPhysicalModel(): GrpcStreamingCall<PhysicalModelValue, PhysicalModelValue>

  /**
   * Atomically set/get the current primary clipboard data.
   */
  fun setClipboard(): GrpcCall<ClipData, Unit>

  fun getClipboard(): GrpcCall<Unit, ClipData>

  /**
   * Streams the current data on the clipboard. This will immediately produce
   * a result with the current state of the clipboard after which the stream
   * will block and wait until a new clip event is available from the guest.
   * Calling the setClipboard method above will not result in generating a clip
   * event. It is possible to lose clipboard events if the clipboard updates
   * very rapidly.
   */
  fun streamClipboard(): GrpcStreamingCall<Unit, ClipData>

  /**
   * Set/get the battery to the given state.
   */
  fun setBattery(): GrpcCall<BatteryState, Unit>

  fun getBattery(): GrpcCall<Unit, BatteryState>

  /**
   * Set the state of the gps, gps support will only work
   * properly if:
   *
   * - no location ui is active. That is the emulator
   *   is launched in headless mode (-no-window) or the location
   *   ui is disabled (-no-location-ui).
   * - the passiveUpdate is set to false. Setting this to false
   *   will disable/break the LocationUI.
   *
   * Keep in mind that android usually only samples the gps at 1 hz.
   */
  fun setGps(): GrpcCall<GpsState, Unit>

  /**
   * Gets the latest gps state as delivered by the setGps call, or location ui
   * if active.
   *
   * Note: this is not neccessarily the actual gps coordinate visible at the
   * time, due to gps sample frequency (usually 1hz).
   */
  fun getGps(): GrpcCall<Unit, GpsState>

  /**
   * Simulate a touch event on the finger print sensor.
   */
  fun sendFingerprint(): GrpcCall<Fingerprint, Unit>

  /**
   * Send a keyboard event. Translating the event.
   */
  fun sendKey(): GrpcCall<KeyboardEvent, Unit>

  /**
   * Send touch/mouse events. Note that mouse events can be simulated
   * by touch events.
   */
  fun sendTouch(): GrpcCall<TouchEvent, Unit>

  fun sendMouse(): GrpcCall<MouseEvent, Unit>

  /**
   * Make a phone call.
   */
  fun sendPhone(): GrpcCall<PhoneCall, PhoneResponse>

  /**
   * Sends an sms message to the emulator.
   */
  fun sendSms(): GrpcCall<SmsMessage, PhoneResponse>

  /**
   * Retrieve the status of the emulator. This will contain general
   * hardware information, and whether the device has booted or not.
   */
  fun getStatus(): GrpcCall<Unit, EmulatorStatus>

  /**
   * Gets an individual screenshot in the desired format.
   *
   * The image will be scaled to the desired ImageFormat, while maintaining
   * the aspect ratio. The returned image will never exceed the provided width
   * and height. Not setting the width or height (i.e. they are 0) will result
   * in using the device width and height.
   *
   * The resulting image will be properly oriented and can be displayed
   * directly without post processing. For example, if the device has a
   * 1080x1920 screen and is in landscape mode and called with no width or
   * height parameter, it will return an 1920x1080 image.
   *
   * This method will return an empty image if the display is not visible.
   */
  fun getScreenshot(): GrpcCall<ImageFormat, Image>

  /**
   * Streams a series of screenshots in the desired format.
   * A new frame will be delivered whenever the device produces a new frame.
   * (Beware that this can produce a significant amount of data, and that
   * certain translations are (png transform) can be costly).
   *
   * If the requested display is not visible it will send a single empty image
   * and wait start producing images once the display becomes active, again
   * producing a single empty image when the display becomes inactive.
   */
  fun streamScreenshot(): GrpcStreamingCall<ImageFormat, Image>

  /**
   * Streams a series of audio packets in the desired format.
   * A new frame will be delivered whenever the emulated device
   * produces a new audio frame.
   */
  fun streamAudio(): GrpcStreamingCall<AudioFormat, AudioPacket>

  /**
   * Returns the last 128Kb of logcat output from the emulator
   * Note that parsed logcat messages are only available after L (Api >23).
   * it is possible that the logcat buffer gets overwritten, or falls behind.
   */
  fun getLogcat(): GrpcCall<LogMessage, LogMessage>

  /**
   * Streams the logcat output from the emulator. The first call
   * can retrieve up to 128Kb. This call will not return.
   * Note that parsed logcat messages are only available after L (Api >23)
   * it is possible that the logcat buffer gets overwritten, or falls behind.
   */
  fun streamLogcat(): GrpcStreamingCall<LogMessage, LogMessage>

  /**
   * Transition the virtual machine to the desired state. Note that
   * some states are only observable. For example you cannot transition
   * to the error state.
   */
  fun setVmState(): GrpcCall<VmRunState, Unit>

  /**
   * Gets the state of the virtual machine.
   */
  fun getVmState(): GrpcCall<Unit, VmRunState>
}
