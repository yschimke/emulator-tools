// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.TouchEvent in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.internal.checkElementsNotNull
import com.squareup.wire.internal.immutableCopyOf
import com.squareup.wire.internal.redactElements
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.collections.List
import kotlin.hashCode
import kotlin.jvm.JvmField
import okio.ByteString

/**
 * A TouchEvent contains a list of Touch objects that are in contact with
 * the touch surface.
 *
 * Touch events are delivered in sequence as specified in the touchList.
 *
 * TouchEvents are delivered to the emulated devices using ["Protocol
 * B"](https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt)
 */
class TouchEvent(
  touches: List<Touch> = emptyList(),
  /**
   * The display device where the touch event occurred.
   * Omitting or using the value 0 indicates the main display.
   *
   * Touch events cannot be send to devices other than 0, due to
   * https://issuetracker.google.com/issues/150699691
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val device: Int = 0,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<TouchEvent, TouchEvent.Builder>(ADAPTER, unknownFields) {
  /**
   * The list of Touch objects, note that these do not need to be unique
   */
  @field:WireField(
    tag = 1,
    adapter = "com.android.emulator.control.Touch#ADAPTER",
    label = WireField.Label.REPEATED
  )
  @JvmField
  val touches: List<Touch> = immutableCopyOf("touches", touches)

  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.touches = touches
    builder.device = device
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is TouchEvent) return false
    if (unknownFields != other.unknownFields) return false
    if (touches != other.touches) return false
    if (device != other.device) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + touches.hashCode()
      result = result * 37 + device.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    if (touches.isNotEmpty()) result += """touches=$touches"""
    result += """device=$device"""
    return result.joinToString(prefix = "TouchEvent{", separator = ", ", postfix = "}")
  }

  fun copy(
    touches: List<Touch> = this.touches,
    device: Int = this.device,
    unknownFields: ByteString = this.unknownFields
  ): TouchEvent = TouchEvent(touches, device, unknownFields)

  class Builder : Message.Builder<TouchEvent, Builder>() {
    @JvmField
    var touches: List<Touch> = emptyList()

    @JvmField
    var device: Int = 0

    /**
     * The list of Touch objects, note that these do not need to be unique
     */
    fun touches(touches: List<Touch>): Builder {
      checkElementsNotNull(touches)
      this.touches = touches
      return this
    }

    /**
     * The display device where the touch event occurred.
     * Omitting or using the value 0 indicates the main display.
     *
     * Touch events cannot be send to devices other than 0, due to
     * https://issuetracker.google.com/issues/150699691
     */
    fun device(device: Int): Builder {
      this.device = device
      return this
    }

    override fun build(): TouchEvent = TouchEvent(
      touches = touches,
      device = device,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<TouchEvent> = object : ProtoAdapter<TouchEvent>(
      FieldEncoding.LENGTH_DELIMITED, 
      TouchEvent::class, 
      "type.googleapis.com/android.emulation.control.TouchEvent", 
      PROTO_3, 
      null
    ) {
      override fun encodedSize(value: TouchEvent): Int {
        var size = value.unknownFields.size
        size += Touch.ADAPTER.asRepeated().encodedSizeWithTag(1, value.touches)
        if (value.device != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(2, value.device)
        return size
      }

      override fun encode(writer: ProtoWriter, value: TouchEvent) {
        Touch.ADAPTER.asRepeated().encodeWithTag(writer, 1, value.touches)
        if (value.device != 0) ProtoAdapter.INT32.encodeWithTag(writer, 2, value.device)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): TouchEvent {
        val touches = mutableListOf<Touch>()
        var device: Int = 0
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> touches.add(Touch.ADAPTER.decode(reader))
            2 -> device = ProtoAdapter.INT32.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return TouchEvent(
          touches = touches,
          device = device,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: TouchEvent): TouchEvent = value.copy(
        touches = value.touches.redactElements(Touch.ADAPTER),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
