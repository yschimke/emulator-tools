// Code generated by Wire protocol buffer compiler, do not edit.
// Source: android.emulation.control.EmulatorController in emulator_controller.proto
package com.android.emulator.control

import com.squareup.wire.GrpcCall
import com.squareup.wire.GrpcClient
import com.squareup.wire.GrpcMethod
import com.squareup.wire.GrpcStreamingCall
import com.squareup.wire.ProtoAdapter
import kotlin.Unit

/**
 * An EmulatorController service lets you control the emulator.
 * Note that this is currently an experimental feature, and that the
 * service definition might change without notice. Use at your own risk!
 *
 * We use the following rough conventions:
 *
 * streamXXX --> streams values XXX (usually for emulator lifetime). Values
 *               are updated as soon as they become available.
 * getXXX    --> gets a single value XXX
 * setXXX    --> sets a single value XXX, does not returning state, these
 *               usually have an observable lasting side effect.
 * sendXXX   --> send a single event XXX, possibly returning state information.
 *               android usually responds to these events.
 */
class GrpcEmulatorControllerClient(
  private val client: GrpcClient
) : EmulatorControllerClient {
  /**
   * set/get/stream the sensor data
   */
  override fun streamSensor(): GrpcStreamingCall<SensorValue, SensorValue> =
      client.newStreamingCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/streamSensor",
      requestAdapter = SensorValue.ADAPTER,
      responseAdapter = SensorValue.ADAPTER
  ))

  override fun getSensor(): GrpcCall<SensorValue, SensorValue> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getSensor",
      requestAdapter = SensorValue.ADAPTER,
      responseAdapter = SensorValue.ADAPTER
  ))

  override fun setSensor(): GrpcCall<SensorValue, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/setSensor",
      requestAdapter = SensorValue.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  /**
   * set/get/stream the physical model, this is likely the one you are
   * looking for when you wish to modify the device state.
   */
  override fun setPhysicalModel(): GrpcCall<PhysicalModelValue, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/setPhysicalModel",
      requestAdapter = PhysicalModelValue.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  override fun getPhysicalModel(): GrpcCall<PhysicalModelValue, PhysicalModelValue> =
      client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getPhysicalModel",
      requestAdapter = PhysicalModelValue.ADAPTER,
      responseAdapter = PhysicalModelValue.ADAPTER
  ))

  override fun streamPhysicalModel(): GrpcStreamingCall<PhysicalModelValue, PhysicalModelValue> =
      client.newStreamingCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/streamPhysicalModel",
      requestAdapter = PhysicalModelValue.ADAPTER,
      responseAdapter = PhysicalModelValue.ADAPTER
  ))

  /**
   * Atomically set/get the current primary clipboard data.
   */
  override fun setClipboard(): GrpcCall<ClipData, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/setClipboard",
      requestAdapter = ClipData.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  override fun getClipboard(): GrpcCall<Unit, ClipData> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getClipboard",
      requestAdapter = ProtoAdapter.EMPTY,
      responseAdapter = ClipData.ADAPTER
  ))

  /**
   * Streams the current data on the clipboard. This will immediately produce
   * a result with the current state of the clipboard after which the stream
   * will block and wait until a new clip event is available from the guest.
   * Calling the setClipboard method above will not result in generating a clip
   * event. It is possible to lose clipboard events if the clipboard updates
   * very rapidly.
   */
  override fun streamClipboard(): GrpcStreamingCall<Unit, ClipData> =
      client.newStreamingCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/streamClipboard",
      requestAdapter = ProtoAdapter.EMPTY,
      responseAdapter = ClipData.ADAPTER
  ))

  /**
   * Set/get the battery to the given state.
   */
  override fun setBattery(): GrpcCall<BatteryState, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/setBattery",
      requestAdapter = BatteryState.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  override fun getBattery(): GrpcCall<Unit, BatteryState> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getBattery",
      requestAdapter = ProtoAdapter.EMPTY,
      responseAdapter = BatteryState.ADAPTER
  ))

  /**
   * Set the state of the gps, gps support will only work
   * properly if:
   *
   * - no location ui is active. That is the emulator
   *   is launched in headless mode (-no-window) or the location
   *   ui is disabled (-no-location-ui).
   * - the passiveUpdate is set to false. Setting this to false
   *   will disable/break the LocationUI.
   *
   * Keep in mind that android usually only samples the gps at 1 hz.
   */
  override fun setGps(): GrpcCall<GpsState, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/setGps",
      requestAdapter = GpsState.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  /**
   * Gets the latest gps state as delivered by the setGps call, or location ui
   * if active.
   *
   * Note: this is not neccessarily the actual gps coordinate visible at the
   * time, due to gps sample frequency (usually 1hz).
   */
  override fun getGps(): GrpcCall<Unit, GpsState> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getGps",
      requestAdapter = ProtoAdapter.EMPTY,
      responseAdapter = GpsState.ADAPTER
  ))

  /**
   * Simulate a touch event on the finger print sensor.
   */
  override fun sendFingerprint(): GrpcCall<Fingerprint, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/sendFingerprint",
      requestAdapter = Fingerprint.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  /**
   * Send a keyboard event. Translating the event.
   */
  override fun sendKey(): GrpcCall<KeyboardEvent, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/sendKey",
      requestAdapter = KeyboardEvent.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  /**
   * Send touch/mouse events. Note that mouse events can be simulated
   * by touch events.
   */
  override fun sendTouch(): GrpcCall<TouchEvent, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/sendTouch",
      requestAdapter = TouchEvent.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  override fun sendMouse(): GrpcCall<MouseEvent, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/sendMouse",
      requestAdapter = MouseEvent.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  /**
   * Make a phone call.
   */
  override fun sendPhone(): GrpcCall<PhoneCall, PhoneResponse> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/sendPhone",
      requestAdapter = PhoneCall.ADAPTER,
      responseAdapter = PhoneResponse.ADAPTER
  ))

  /**
   * Sends an sms message to the emulator.
   */
  override fun sendSms(): GrpcCall<SmsMessage, PhoneResponse> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/sendSms",
      requestAdapter = SmsMessage.ADAPTER,
      responseAdapter = PhoneResponse.ADAPTER
  ))

  /**
   * Retrieve the status of the emulator. This will contain general
   * hardware information, and whether the device has booted or not.
   */
  override fun getStatus(): GrpcCall<Unit, EmulatorStatus> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getStatus",
      requestAdapter = ProtoAdapter.EMPTY,
      responseAdapter = EmulatorStatus.ADAPTER
  ))

  /**
   * Gets an individual screenshot in the desired format.
   *
   * The image will be scaled to the desired ImageFormat, while maintaining
   * the aspect ratio. The returned image will never exceed the provided width
   * and height. Not setting the width or height (i.e. they are 0) will result
   * in using the device width and height.
   *
   * The resulting image will be properly oriented and can be displayed
   * directly without post processing. For example, if the device has a
   * 1080x1920 screen and is in landscape mode and called with no width or
   * height parameter, it will return an 1920x1080 image.
   *
   * This method will return an empty image if the display is not visible.
   */
  override fun getScreenshot(): GrpcCall<ImageFormat, Image> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getScreenshot",
      requestAdapter = ImageFormat.ADAPTER,
      responseAdapter = Image.ADAPTER
  ))

  /**
   * Streams a series of screenshots in the desired format.
   * A new frame will be delivered whenever the device produces a new frame.
   * (Beware that this can produce a significant amount of data, and that
   * certain translations are (png transform) can be costly).
   *
   * If the requested display is not visible it will send a single empty image
   * and wait start producing images once the display becomes active, again
   * producing a single empty image when the display becomes inactive.
   */
  override fun streamScreenshot(): GrpcStreamingCall<ImageFormat, Image> =
      client.newStreamingCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/streamScreenshot",
      requestAdapter = ImageFormat.ADAPTER,
      responseAdapter = Image.ADAPTER
  ))

  /**
   * Streams a series of audio packets in the desired format.
   * A new frame will be delivered whenever the emulated device
   * produces a new audio frame.
   */
  override fun streamAudio(): GrpcStreamingCall<AudioFormat, AudioPacket> =
      client.newStreamingCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/streamAudio",
      requestAdapter = AudioFormat.ADAPTER,
      responseAdapter = AudioPacket.ADAPTER
  ))

  /**
   * Returns the last 128Kb of logcat output from the emulator
   * Note that parsed logcat messages are only available after L (Api >23).
   * it is possible that the logcat buffer gets overwritten, or falls behind.
   */
  override fun getLogcat(): GrpcCall<LogMessage, LogMessage> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getLogcat",
      requestAdapter = LogMessage.ADAPTER,
      responseAdapter = LogMessage.ADAPTER
  ))

  /**
   * Streams the logcat output from the emulator. The first call
   * can retrieve up to 128Kb. This call will not return.
   * Note that parsed logcat messages are only available after L (Api >23)
   * it is possible that the logcat buffer gets overwritten, or falls behind.
   */
  override fun streamLogcat(): GrpcStreamingCall<LogMessage, LogMessage> =
      client.newStreamingCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/streamLogcat",
      requestAdapter = LogMessage.ADAPTER,
      responseAdapter = LogMessage.ADAPTER
  ))

  /**
   * Transition the virtual machine to the desired state. Note that
   * some states are only observable. For example you cannot transition
   * to the error state.
   */
  override fun setVmState(): GrpcCall<VmRunState, Unit> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/setVmState",
      requestAdapter = VmRunState.ADAPTER,
      responseAdapter = ProtoAdapter.EMPTY
  ))

  /**
   * Gets the state of the virtual machine.
   */
  override fun getVmState(): GrpcCall<Unit, VmRunState> = client.newCall(GrpcMethod(
      path = "/android.emulation.control.EmulatorController/getVmState",
      requestAdapter = ProtoAdapter.EMPTY,
      responseAdapter = VmRunState.ADAPTER
  ))
}
