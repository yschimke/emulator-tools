// Code generated by Wire protocol buffer compiler, do not edit.
// Source: waterfall.Cmd in waterfall.proto
package com.google.waterfall

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.internal.checkElementsNotNull
import com.squareup.wire.internal.immutableCopyOf
import com.squareup.wire.internal.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.lazy
import okio.ByteString

class Cmd(
  /**
   * Path to the binary to execute.
   * Path should be absolute. Otherwise behavior is not specified.
   * use /system/bin/sh -c to run in a shell.
   * Interactive shell is not supported.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val path: String = "",
  args: List<String> = emptyList(),
  /**
   * Directory to execute the command
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val dir: String = "",
  /**
   * Whether to pipe stdin to the command
   */
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#BOOL",
    label = WireField.Label.OMIT_IDENTITY
  )
  @JvmField
  val pipeIn: Boolean = false,
  env: Map<String, String> = emptyMap(),
  unknownFields: ByteString = ByteString.EMPTY
) : Message<Cmd, Cmd.Builder>(ADAPTER, unknownFields) {
  /**
   * Args to pass to the command
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.REPEATED
  )
  @JvmField
  val args: List<String> = immutableCopyOf("args", args)

  /**
   * Environment to use
   */
  @field:WireField(
    tag = 5,
    keyAdapter = "com.squareup.wire.ProtoAdapter#STRING",
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  @JvmField
  val env: Map<String, String> = immutableCopyOf("env", env)

  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.path = path
    builder.args = args
    builder.dir = dir
    builder.pipeIn = pipeIn
    builder.env = env
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is Cmd) return false
    if (unknownFields != other.unknownFields) return false
    if (path != other.path) return false
    if (args != other.args) return false
    if (dir != other.dir) return false
    if (pipeIn != other.pipeIn) return false
    if (env != other.env) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + path.hashCode()
      result = result * 37 + args.hashCode()
      result = result * 37 + dir.hashCode()
      result = result * 37 + pipeIn.hashCode()
      result = result * 37 + env.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """path=${sanitize(path)}"""
    if (args.isNotEmpty()) result += """args=${sanitize(args)}"""
    result += """dir=${sanitize(dir)}"""
    result += """pipeIn=$pipeIn"""
    if (env.isNotEmpty()) result += """env=$env"""
    return result.joinToString(prefix = "Cmd{", separator = ", ", postfix = "}")
  }

  fun copy(
    path: String = this.path,
    args: List<String> = this.args,
    dir: String = this.dir,
    pipeIn: Boolean = this.pipeIn,
    env: Map<String, String> = this.env,
    unknownFields: ByteString = this.unknownFields
  ): Cmd = Cmd(path, args, dir, pipeIn, env, unknownFields)

  class Builder : Message.Builder<Cmd, Builder>() {
    @JvmField
    var path: String = ""

    @JvmField
    var args: List<String> = emptyList()

    @JvmField
    var dir: String = ""

    @JvmField
    var pipeIn: Boolean = false

    @JvmField
    var env: Map<String, String> = emptyMap()

    /**
     * Path to the binary to execute.
     * Path should be absolute. Otherwise behavior is not specified.
     * use /system/bin/sh -c to run in a shell.
     * Interactive shell is not supported.
     */
    fun path(path: String): Builder {
      this.path = path
      return this
    }

    /**
     * Args to pass to the command
     */
    fun args(args: List<String>): Builder {
      checkElementsNotNull(args)
      this.args = args
      return this
    }

    /**
     * Directory to execute the command
     */
    fun dir(dir: String): Builder {
      this.dir = dir
      return this
    }

    /**
     * Whether to pipe stdin to the command
     */
    fun pipeIn(pipeIn: Boolean): Builder {
      this.pipeIn = pipeIn
      return this
    }

    /**
     * Environment to use
     */
    fun env(env: Map<String, String>): Builder {
      this.env = env
      return this
    }

    override fun build(): Cmd = Cmd(
      path = path,
      args = args,
      dir = dir,
      pipeIn = pipeIn,
      env = env,
      unknownFields = buildUnknownFields()
    )
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<Cmd> = object : ProtoAdapter<Cmd>(
      FieldEncoding.LENGTH_DELIMITED, 
      Cmd::class, 
      "type.googleapis.com/waterfall.Cmd", 
      PROTO_3, 
      null
    ) {
      private val envAdapter: ProtoAdapter<Map<String, String>> by lazy {
          ProtoAdapter.newMapAdapter(ProtoAdapter.STRING, ProtoAdapter.STRING) }

      override fun encodedSize(value: Cmd): Int {
        var size = value.unknownFields.size
        if (value.path != "") size += ProtoAdapter.STRING.encodedSizeWithTag(1, value.path)
        size += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(2, value.args)
        if (value.dir != "") size += ProtoAdapter.STRING.encodedSizeWithTag(3, value.dir)
        if (value.pipeIn != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(4, value.pipeIn)
        size += envAdapter.encodedSizeWithTag(5, value.env)
        return size
      }

      override fun encode(writer: ProtoWriter, value: Cmd) {
        if (value.path != "") ProtoAdapter.STRING.encodeWithTag(writer, 1, value.path)
        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 2, value.args)
        if (value.dir != "") ProtoAdapter.STRING.encodeWithTag(writer, 3, value.dir)
        if (value.pipeIn != false) ProtoAdapter.BOOL.encodeWithTag(writer, 4, value.pipeIn)
        envAdapter.encodeWithTag(writer, 5, value.env)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): Cmd {
        var path: String = ""
        val args = mutableListOf<String>()
        var dir: String = ""
        var pipeIn: Boolean = false
        val env = mutableMapOf<String, String>()
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> path = ProtoAdapter.STRING.decode(reader)
            2 -> args.add(ProtoAdapter.STRING.decode(reader))
            3 -> dir = ProtoAdapter.STRING.decode(reader)
            4 -> pipeIn = ProtoAdapter.BOOL.decode(reader)
            5 -> env.putAll(envAdapter.decode(reader))
            else -> reader.readUnknownField(tag)
          }
        }
        return Cmd(
          path = path,
          args = args,
          dir = dir,
          pipeIn = pipeIn,
          env = env,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: Cmd): Cmd = value.copy(
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
